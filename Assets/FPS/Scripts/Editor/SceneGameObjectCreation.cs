using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using TutorialFPS.Services;
using UnityEditor;
using UnityEngine;
using Random = UnityEngine.Random;

namespace TutorialFPS.Editor
{
    public class SceneGameObjectCreation : EditorWindow
    {
        private static List<int> _autogeneratedGameObjectsIDs = new List<int>();

        private int _countObjectTypes;
        private SceneCreatableGameObject[] _gameObjs;
        private int _maxAttempts;
        private string _groundTag;
        private Vector2 scrollPos;

        [MenuItem("TutorialFPS/Create gameobjects")]
        public static void ShowWindow()
        {
            GetWindow(typeof(SceneGameObjectCreation));
        }

        void OnGUI()
        {
            GUILayout.MinWidth(500f);

            GUILayout.Label("GameObjects", EditorStyles.boldLabel);
            _countObjectTypes = EditorGUILayout.IntField("Object Types Count", _countObjectTypes);
            if (_gameObjs==null||_countObjectTypes != _gameObjs.Length)
            {
                _gameObjs = new SceneCreatableGameObject[_countObjectTypes];
            }
            
            scrollPos = EditorGUILayout.BeginScrollView(scrollPos);

            for (int i = 0; i < _countObjectTypes; i++)
            {
                EditorGUILayout.BeginHorizontal();

                if (_gameObjs[i] == null)
                {
                    _gameObjs[i] = new SceneCreatableGameObject();

                }

                _gameObjs[i].Prefab = EditorGUILayout.ObjectField("GameObject: ", _gameObjs[i].Prefab, typeof(GameObject), true) as GameObject;
                _gameObjs[i].Name = EditorGUILayout.TextField("Name: ", _gameObjs[i].Name);
                _gameObjs[i].Count = EditorGUILayout.IntField("Count: ", _gameObjs[i].Count);

                EditorGUILayout.EndHorizontal();
            }
            EditorGUILayout.EndScrollView();

            EditorGUILayout.BeginHorizontal();

            EditorGUILayout.LabelField("Ground gameobjects tag, where generated gameobjects can be placed: ", EditorStyles.wordWrappedLabel);
            _groundTag = EditorGUILayout.TagField(_groundTag);

            EditorGUILayout.EndHorizontal();
            EditorGUILayout.BeginHorizontal();

            EditorGUILayout.LabelField("Max creation attempts for every gameobject: ", EditorStyles.wordWrappedLabel);
            _maxAttempts = EditorGUILayout.IntSlider(_maxAttempts, 1, 20);

            EditorGUILayout.EndHorizontal();

            GUI.enabled = !String.IsNullOrEmpty(_groundTag) && _countObjectTypes > 0;

            if (GUILayout.Button("Create"))
            {
                CreateGameObjects();
            }

            GUI.enabled = true;
        }

        private void CreateGameObjects()
        {
            Renderer[] groundObjs = GetGroundObjectsRenderers();

            GameObject root = new GameObject("Autocreated GameObjects");
            for (int i = 0; i < _gameObjs.Length; i++)
            {
                for (int j = 0; j < Mathf.Max(_gameObjs[i].Count, 1); j++)
                {
                    Vector3? instantiatePosition = TryFindInstantiationPoint(_gameObjs[i].Prefab, groundObjs);
                    if (instantiatePosition == null)
                    {
                        continue;
                    }
                    GameObject temp = Instantiate(_gameObjs[i].Prefab, (Vector3)instantiatePosition,
                        _gameObjs[i].Prefab.transform.rotation);

                    temp.name = (string.IsNullOrEmpty(_gameObjs[i].Name) ? _gameObjs[i].Prefab.name : _gameObjs[i].Name) + "_" + (j + 1);
                    temp.transform.parent = root.transform;
                    _autogeneratedGameObjectsIDs.Add(temp.GetInstanceID());
                }
            }

            SetUniqueNames();
        }

        private Renderer[] GetGroundObjectsRenderers()
        {
            return GameObject.FindGameObjectsWithTag(_groundTag).SelectMany(x => x.GetComponentsInChildren<Renderer>()).ToArray();
        }

        private Vector3? TryFindInstantiationPoint(GameObject prefab, Renderer[] groundObjects)
        {
            if (prefab == null)
            {
                return null;
            }

            float prefabRendererMinX = float.MaxValue;
            float prefabRendererMinY = float.MaxValue;
            float prefabRendererMinZ = float.MaxValue;
            float prefabRendererMaxX = float.MinValue;
            float prefabRendererMaxY = float.MinValue;
            float prefabRendererMaxZ = float.MinValue;
            foreach (Renderer renderer in prefab.GetComponentsInChildren<Renderer>())
            {
                if (renderer.bounds.min.x < prefabRendererMinX)
                {
                    prefabRendererMinX = renderer.bounds.min.x;
                }
                if (renderer.bounds.min.y < prefabRendererMinY)
                {
                    prefabRendererMinY = renderer.bounds.min.y;
                }
                if (renderer.bounds.min.z < prefabRendererMinZ)
                {
                    prefabRendererMinZ = renderer.bounds.min.z;
                }
                if (renderer.bounds.max.x > prefabRendererMaxX)
                {
                    prefabRendererMaxX = renderer.bounds.max.x;
                }
                if (renderer.bounds.max.y > prefabRendererMaxY)
                {
                    prefabRendererMaxY = renderer.bounds.max.y;
                }
                if (renderer.bounds.max.z > prefabRendererMaxZ)
                {
                    prefabRendererMaxZ = renderer.bounds.max.z;
                }
            }

            float xSize = prefabRendererMaxX - prefabRendererMinX;
            float ySize = prefabRendererMaxY - prefabRendererMinY;
            float zSize = prefabRendererMaxZ - prefabRendererMinZ;

            Vector3 centerPoint = new Vector3(prefabRendererMaxX - xSize / 2, prefabRendererMaxY - ySize / 2, prefabRendererMaxZ - zSize / 2);
            Vector3 offset = prefab.transform.position - centerPoint;

            for (int i = 0; i < _maxAttempts; i++)
            {
                groundObjects = Reshuffle(groundObjects);
                for (int j = 0; j < groundObjects.Length; j++)
                {
                    float groundRendererMinX = groundObjects[j].bounds.min.x;
                    float groundRendererMinZ = groundObjects[j].bounds.min.z;
                    float groundRendererMaxX = groundObjects[j].bounds.max.x;
                    float groundRendererMaxZ = groundObjects[j].bounds.max.z;
                    float groundRendererMaxY = groundObjects[j].bounds.max.y;

                    float minX = groundRendererMinX + xSize / 2;
                    float minZ = groundRendererMinZ + zSize / 2;
                    float maxX = groundRendererMaxX - xSize / 2;
                    float maxZ = groundRendererMaxZ - zSize / 2;
                    if (minX < maxX && minZ < maxZ)
                    {
                        Vector2 randomXZPoint = new Vector2(Random.Range(minX, maxX), Random.Range(minZ, maxZ));
                        Vector3 apropriateCenterObjectPoint = new Vector3(randomXZPoint.x, groundRendererMaxY + ySize / 2+0.01f, randomXZPoint.y);

                        if (CheckSpaceForObject(apropriateCenterObjectPoint, xSize, ySize, zSize))
                        {
                            return apropriateCenterObjectPoint + offset;
                        }
                    }
                }
            }

            return null;
        }

        private T[] Reshuffle<T>(T[] objs)
        {
            for (int t = 0; t < objs.Length; t++)
            {
                T tmp = objs[t];
                int r = Random.Range(t, objs.Length);
                objs[t] = objs[r];
                objs[r] = tmp;
            }

            return objs;
        }

        private bool CheckSpaceForObject(Vector3 centerPoint, float xSize, float ySize, float zSize)
        {
            return !Physics.CheckBox(centerPoint, new Vector3(xSize / 2, ySize / 2, zSize / 2));
        }

        [MenuItem("TutorialFPS/Delete autogenerated gameobjects")]
        public static void DeleteObjects()
        {
            foreach (int gameObjectsID in _autogeneratedGameObjectsIDs)
            {
                DestroyImmediate(EditorUtility.InstanceIDToObject(gameObjectsID));
            }

            _autogeneratedGameObjectsIDs.Clear();
        }

        [MenuItem("TutorialFPS/Delete autogenerated gameobjects", true)]
        public static bool CheckDeletingObjects()
        {
            return _autogeneratedGameObjectsIDs.Count > 0;
        }

        #region UniqueNames

        private static readonly Dictionary<string, int> _nameDictionary = new
            Dictionary<string, int>();


        [MenuItem("TutorialFPS/Set unique names")]
        public static void SetUniqueNames()
        {
            var sceneObj = FindObjectsOfType(typeof(GameObject)) as GameObject[]; 

            if (sceneObj != null)
            {
                foreach (var obj in sceneObj)
                {
                    DataCollection(obj);
                }
            }
            foreach (var i in _nameDictionary)
            {
                for (var j = 0; j < i.Value; j++)
                {
                    var gameObj = GameObject.Find(i.Key);
                    if (gameObj)
                    {
                        gameObj.name += "(" + j + ")";
                    }
                }
            }
            _nameDictionary.Clear();
        }

        /// <summary>
        /// Собирает информацию об объекте (имя и индекс)
        /// </summary>
        /// <param name="sceneObj">Объект на сцене</param>
        private static void DataCollection(GameObject sceneObj)
        {
            string[] tempName = sceneObj.name.Split('(');
            tempName[0] = tempName[0].Trim(); // Убираем пробелы
            if (!_nameDictionary.ContainsKey(tempName[0]))
            {
                _nameDictionary.Add(tempName[0], 0);
            }
            else
            {
                _nameDictionary[tempName[0]]++;
            }
            sceneObj.name = tempName[0];
        }

        #endregion
    }
}

